<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>XGP 석궁 미니게임</title>
  <style>
    :root{
      --panel: rgba(10,14,22,.72);
      --panel2: rgba(10,14,22,.55);
      --line: rgba(255,255,255,.10);
      --gold: #ffd54a;
      --mint: #2ef2c2;
      --warn: #ff3b5c;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.64);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      min-height:100svh;
      display:grid;
      place-items:center;
      background: radial-gradient(1200px 700px at 50% 20%, #111b34 0%, #080b14 55%, #05070d 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      overflow:hidden;
      padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right))
               max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
    }

    /* Desktop default */
    .wrap{
      width:min(980px, 96vw);
      height: min(720px, 92svh);
      display:grid;
      grid-template-rows:auto 1fr;
      gap:10px;
    }

    .topbar{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .hud{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-weight:900; }
    .pill{
      display:flex; gap:8px; align-items:center;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .pill b{color:rgba(255,255,255,.95)}
    .pill span{color:var(--muted); font-weight:800}

    .btns{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button{
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-weight:950;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.18); }
    button:active{ transform: translateY(1px) scale(.99); }

    .diff{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      padding:6px 8px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .chip{
      padding:8px 10px;
      border-radius:999px;
      font-weight:950;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      cursor:pointer;
      transition: .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .chip.is-on{
      background: rgba(255,213,74,.16);
      border-color: rgba(255,213,74,.35);
      box-shadow: 0 10px 22px rgba(255,213,74,.08);
    }
    .hint{ color: rgba(255,255,255,.64); font-weight:850; margin-left:4px; font-size: 12px; }

    .stage{
      position:relative;
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      box-shadow: 0 20px 70px rgba(0,0,0,.45);
      width:100%;
      aspect-ratio: 16/9;             /* ✅ 항상 16:9 유지 */
      max-height: calc(92svh - 88px); /* ✅ 상단바 고려 */
      display:grid;
      place-items:center;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
      background: #070a10;
      image-rendering: auto;
    }

    .overlay{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background: radial-gradient(900px 500px at 50% 30%, rgba(0,0,0,.60) 0%, rgba(0,0,0,.82) 70%, rgba(0,0,0,.92) 100%);
      backdrop-filter: blur(7px);
    }
    .card{
      width:min(560px, 92%);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(18,22,34,.84), rgba(10,12,18,.84));
      box-shadow: 0 24px 90px rgba(0,0,0,.55);
      padding:18px 16px 16px;
    }
    .title{
      font-size:20px;
      font-weight:950;
      letter-spacing:.3px;
      margin:0 0 8px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:950;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,213,74,.32);
      background: rgba(255,213,74,.14);
      color: rgba(255,243,215,.96);
      font-size:12px;
      white-space:nowrap;
    }
    .desc{
      margin:0 0 12px;
      color: rgba(255,255,255,.78);
      line-height:1.45;
      font-weight:750;
    }
    .desc b{color: rgba(255,255,255,.95)}
    .desc .gold{color: rgba(255,213,74,.95); font-weight:950}
    .desc .warn{color: rgba(255,59,92,.95); font-weight:950}
    .final{
      margin:10px 0 14px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      font-weight:950;
      color: rgba(255,255,255,.86);
      line-height:1.55;
    }
    .final .gold{color: rgba(255,213,74,.95); font-weight:950}
    .actions{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
    }
    .actions .left{display:flex; gap:10px; flex-wrap:wrap}
    .note{ color: rgba(255,255,255,.58); font-size:12px; font-weight:800; }

    /* ✅ Mobile: 늘어짐 방지 + 안전영역 + 풀스크린 느낌 */
    @media (max-width: 720px){
      body{
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      .wrap{
        width:100vw;
        height:100svh;
        padding:10px;
        gap:8px;
      }
      .topbar{
        padding:8px 10px;
        border-radius:16px;
      }
      .pill{
        padding:6px 8px;
        font-size:12px;
      }
      .diff{
        padding:5px 6px;
        gap:6px;
      }
      .chip{
        padding:7px 9px;
        font-size:12px;
        border-radius:999px;
      }
      .hint{display:none;}
      button{
        padding:8px 10px;
        font-size:12px;
        border-radius:12px;
      }
      .stage{
        max-height: none;
        height: calc(100svh - 96px);  /* ✅ 상단바 높이 고려 */
        aspect-ratio: 16/9;           /* ✅ 모바일에서도 고정 */
      }
      .card{padding:16px 14px}
      .title{font-size:18px}
      .note{font-size:11px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="hud">
        <div class="pill"><span>TIME</span> <b id="timeText">30.0</b></div>
        <div class="pill"><span>SCORE</span> <b id="scoreText">0</b></div>
        <div class="pill"><span>BEST</span> <b id="bestText">0</b></div>
        <div class="pill"><span>DIFF</span> <b id="diffText">EASY</b></div>
      </div>

      <div class="btns">
        <div class="diff">
          <div class="chip is-on" data-diff="EASY">EASY</div>
          <div class="chip" data-diff="NORMAL">NORMAL</div>
          <div class="chip" data-diff="HARD">HARD</div>
          <div class="hint" id="diffHint">EASY: 기본 속도</div>
        </div>
        <button id="resetBtn" title="R 키로도 가능">RESET</button>
        <button id="resetBestBtn">RESET BEST</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="overlay" id="overlay">
        <div class="card">
          <div class="title">
            <span class="badge">XGP CROSSBOW RANGE</span>
            <span id="ovTitle">XGP 석궁 미니게임</span>
          </div>
          <p class="desc" id="ovDesc"></p>
          <div class="final" id="ovFinal" style="display:none"></div>
          <div class="actions">
            <div class="left">
              <button id="startBtn">START</button>
              <button id="resetBtn2">CLOSE</button>
            </div>
            <div class="note">드래그/이동 조준 → 떼면 발사 / Space 발사 / R 리셋</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== DOM =====
  const canvas = document.getElementById("game");
  const stageEl = document.getElementById("stage");
  const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });

  const timeText = document.getElementById("timeText");
  const scoreText = document.getElementById("scoreText");
  const bestText = document.getElementById("bestText");
  const diffText = document.getElementById("diffText");

  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const resetBestBtn = document.getElementById("resetBestBtn");
  const resetBtn = document.getElementById("resetBtn");
  const resetBtn2 = document.getElementById("resetBtn2");

  const ovTitle = document.getElementById("ovTitle");
  const ovDesc = document.getElementById("ovDesc");
  const ovFinal = document.getElementById("ovFinal");

  const diffHint = document.getElementById("diffHint");
  const diffButtons = [...document.querySelectorAll(".chip")];

  // ===== Utils =====
  let W = canvas.width;
  let H = canvas.height;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  // playfield (will recompute on resize)
  let TOP = 88;
  let BOTTOM = H - 108;
  let LEFT = 26;
  let RIGHT = W - 26;

  // ✅ DPR-resize: 모바일에서 뿌옇거나 늘어지는 느낌 제거 + 입력 좌표 정확
  function resizeCanvasToStage(){
    const rect = stageEl.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2.25, window.devicePixelRatio || 1)); // 과도한 dpr 제한
    const targetW = Math.max(320, Math.round(rect.width * dpr));
    const targetH = Math.max(180, Math.round(rect.height * dpr));

    if (canvas.width !== targetW || canvas.height !== targetH){
      canvas.width = targetW;
      canvas.height = targetH;
      W = canvas.width;
      H = canvas.height;

      // playfield 갱신
      TOP = Math.round(H * 0.16);
      BOTTOM = Math.round(H * 0.80);
      LEFT = Math.round(W * 0.03);
      RIGHT = Math.round(W * 0.97);

      // 플레이어 위치도 화면 비율에 맞게 재배치
      player.x = W * 0.5;
      player.y = H * 0.86;

      // 배경 재생성
      bgCanvas.width = W;
      bgCanvas.height = H;
      buildBackground();
    }
  }
  window.addEventListener("resize", () => resizeCanvasToStage(), { passive: true });

  function drawRoundedRect(x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }
  function canvasToLocal(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const sx = (clientX - rect.left) / rect.width;
    const sy = (clientY - rect.top) / rect.height;
    return { x: sx * W, y: sy * H };
  }

  // ===== Stable RNG (배경 고정) =====
  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  const bgRand = mulberry32(0xC0FFEE);

  // ===== Audio (no files) =====
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
  }
  function beep({ type="square", f0=700, f1=420, dur=0.08, gain=0.06, curve="exp" }) {
    try {
      ensureAudio();
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;

      o.frequency.setValueAtTime(f0, t);
      if (curve === "exp") o.frequency.exponentialRampToValueAtTime(Math.max(40, f1), t + dur);
      else o.frequency.linearRampToValueAtTime(f1, t + dur);

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      o.connect(g); g.connect(audioCtx.destination);
      o.start(t); o.stop(t + dur + 0.02);
    } catch {}
  }
  const sfx = {
    shoot() { beep({ type:"square", f0:720, f1:280, dur:0.07, gain:0.05 }); },
    hit()   { beep({ type:"triangle", f0:980, f1:560, dur:0.09, gain:0.06 }); },
    crit()  { beep({ type:"sawtooth", f0:1500, f1:740, dur:0.11, gain:0.065 }); },
    boom()  { beep({ type:"sawtooth", f0:220, f1:65, dur:0.15, gain:0.075, curve:"lin" }); },
    timeup(){ beep({ type:"triangle", f0:420, f1:140, dur:0.19, gain:0.06 }); },
  };

  // ===== Difficulty =====
  const DIFF = {
    EASY:   { coins: 3, hazards: 4, move: 1.00, wind: 0.0, arrowCd: 190, bonus: 1.00, time: 30 },
    NORMAL: { coins: 4, hazards: 6, move: 1.25, wind: 1.0, arrowCd: 230, bonus: 1.08, time: 30 },
    HARD:   { coins: 5, hazards: 8, move: 1.50, wind: 1.8, arrowCd: 280, bonus: 1.15, time: 30 },
  };
  const DIFF_HINTS = {
    EASY:   "EASY: 기본 속도",
    NORMAL: "NORMAL: 더 빠름 + 바람",
    HARD:   "HARD: 매우 빠름 + 강한 바람",
  };

  let difficulty = "EASY";
  function setDifficulty(d) {
    difficulty = d;
    diffButtons.forEach(b => b.classList.toggle("is-on", b.dataset.diff === d));
    if (diffHint) diffHint.textContent = DIFF_HINTS[d] || "";
    diffText.textContent = d;
  }
  diffButtons.forEach(btn => btn.addEventListener("click", () => setDifficulty(btn.dataset.diff)));
  setDifficulty("EASY");

  // ===== Best =====
  const BEST_KEY = "xgp_crossbow_best_v8";
  let best = Number(localStorage.getItem(BEST_KEY) || 0);

  // ===== Assets (embedded SVG) =====
  function svgToImg(svg) {
    const img = new Image();
    img.decoding = "async";
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg.trim());
    return img;
  }

  // ✅ 더 멋진 “올우드(회색 금속 느낌 최소화)” 석궁
  const crossbowImg = svgToImg(`
  <svg xmlns="http://www.w3.org/2000/svg" width="720" height="420" viewBox="0 0 720 420">
    <defs>
      <linearGradient id="woodA" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#a76b35"/>
        <stop offset="0.45" stop-color="#7a4520"/>
        <stop offset="1" stop-color="#3b1d0b"/>
      </linearGradient>
      <linearGradient id="woodB" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0" stop-color="#d59a5a"/>
        <stop offset="0.35" stop-color="#9b5a2a"/>
        <stop offset="1" stop-color="#5a2a10"/>
      </linearGradient>
      <linearGradient id="gold" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#fff3c8"/>
        <stop offset="0.35" stop-color="#ffd54a"/>
        <stop offset="1" stop-color="#c57a00"/>
      </linearGradient>
      <radialGradient id="shine" cx="30%" cy="25%" r="70%">
        <stop offset="0" stop-color="#ffffff" stop-opacity="0.55"/>
        <stop offset="0.35" stop-color="#ffffff" stop-opacity="0.16"/>
        <stop offset="1" stop-color="#ffffff" stop-opacity="0"/>
      </radialGradient>
      <filter id="sh" x="-30%" y="-30%" width="160%" height="160%">
        <feDropShadow dx="0" dy="10" stdDeviation="10" flood-color="#000" flood-opacity="0.45"/>
      </filter>
    </defs>

    <g filter="url(#sh)" transform="translate(26,24)">
      <!-- body -->
      <path d="M270 250
               C225 305,212 352,236 370
               C270 392,330 350,360 318
               C400 274,412 260,438 258
               C470 255,500 278,522 270
               C552 258,572 230,564 206
               C552 168,502 164,478 186
               C458 204,436 196,412 176
               C368 140,318 170,300 192
               C288 206,286 230,270 250 Z"
            fill="url(#woodA)" stroke="#1a0c05" stroke-width="8" />

      <!-- inlay -->
      <path d="M302 232 C275 272,266 342,296 360"
            fill="none" stroke="rgba(255,235,200,.28)" stroke-width="10" stroke-linecap="round"/>

      <!-- stock rail -->
      <path d="M310 120 L560 210 L534 250 L286 158 Z"
            fill="url(#woodB)" stroke="#241107" stroke-width="8" />

      <!-- trigger housing (dark wood) -->
      <rect x="308" y="172" width="82" height="74" rx="14"
            fill="#2a1408" stroke="#140903" stroke-width="8"/>
      <path d="M348 220 C342 246,360 270,384 278"
            fill="none" stroke="#0c0502" stroke-width="10" stroke-linecap="round"/>

      <!-- bow arms -->
      <path d="M88 92 C210 80,290 120,326 148"
            fill="none" stroke="#2b1408" stroke-width="26" stroke-linecap="round"/>
      <path d="M96 92 C214 84,288 122,326 148"
            fill="none" stroke="rgba(255,235,200,.18)" stroke-width="10" stroke-linecap="round"/>

      <path d="M120 320 C224 280,284 214,326 148"
            fill="none" stroke="#2b1408" stroke-width="26" stroke-linecap="round"/>
      <path d="M128 320 C226 282,284 216,326 148"
            fill="none" stroke="rgba(255,235,200,.16)" stroke-width="10" stroke-linecap="round"/>

      <!-- string -->
      <path d="M102 92 L126 320" stroke="rgba(255,245,220,.95)" stroke-width="4" stroke-linecap="round"/>
      <path d="M102 92 L126 320" stroke="rgba(0,0,0,.22)" stroke-width="7" stroke-linecap="round"/>

      <!-- bolt -->
      <path d="M324 150 L586 236" stroke="rgba(255,245,220,.95)" stroke-width="10" stroke-linecap="round"/>
      <path d="M560 228 L624 250" stroke="rgba(46,242,194,.95)" stroke-width="12" stroke-linecap="round"/>
      <path d="M588 238 L652 218 L652 280 Z" fill="url(#gold)" stroke="#4a2300" stroke-width="8"/>

      <!-- gold details -->
      <circle cx="404" cy="214" r="10" fill="url(#gold)" stroke="#4a2300" stroke-width="6"/>
      <circle cx="468" cy="236" r="10" fill="url(#gold)" stroke="#4a2300" stroke-width="6"/>

      <!-- gloss -->
      <ellipse cx="420" cy="190" rx="300" ry="220" fill="url(#shine)"/>
    </g>
  </svg>`);

  const starImg = svgToImg(`
  <svg xmlns="http://www.w3.org/2000/svg" width="180" height="180" viewBox="0 0 128 128">
    <defs>
      <radialGradient id="g" cx="35%" cy="30%" r="80%">
        <stop offset="0" stop-color="#fffbe6"/>
        <stop offset="0.38" stop-color="#ffd54a"/>
        <stop offset="1" stop-color="#f0a800"/>
      </radialGradient>
      <filter id="s" x="-30%" y="-30%" width="160%" height="160%">
        <feDropShadow dx="0" dy="8" stdDeviation="8" flood-color="#000" flood-opacity="0.40"/>
      </filter>
    </defs>
    <g filter="url(#s)">
      <path d="M64 10 L78 46 L118 46 L86 70 L98 110 L64 86 L30 110 L42 70 L10 46 L50 46 Z"
            fill="url(#g)" stroke="rgba(255,245,210,0.92)" stroke-width="5" />
      <path d="M50 44 C58 32,78 32,86 44" fill="none" stroke="#ffffff" stroke-opacity="0.35" stroke-width="7" stroke-linecap="round"/>
    </g>
  </svg>`);

  // ===== Game State =====
  let running = false;
  let lastTs = 0;

  let elapsed = 0;
  let score = 0;
  let remaining = DIFF[difficulty].time;

  const player = { x: W / 2, y: H * 0.86, r: 18 };
  const aim = { angle: -Math.PI / 2, smooth: -Math.PI / 2 };

  let arrows = [];
  let coins = [];
  let hazards = [];
  let particles = [];
  let popups = [];

  let arrowCooldown = 0;

  let shakeT = 0;
  let shakePow = 0;

  // ===== Helpers =====
  function rnd(min, max) { return min + Math.random() * (max - min); }
  function updateAimFromPointer(clientX, clientY) {
    const p = canvasToLocal(clientX, clientY);
    const dx = p.x - player.x;
    const dy = p.y - player.y;
    if (dy > 0) return;
    aim.angle = Math.atan2(dy, dx);
    aim.angle = clamp(aim.angle, -Math.PI + 0.26, -0.23);
  }
  function addShake(pow, t=0.16){
    shakePow = Math.max(shakePow, pow);
    shakeT = Math.max(shakeT, t);
  }

  // ===== FX =====
  function burst(x, y, n, kind) {
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const s = 90 + Math.random() * 240;
      const size = 2 + Math.random() * 3;
      particles.push({
        x, y,
        vx: Math.cos(a) * s,
        vy: Math.sin(a) * s,
        life: 0.35 + Math.random() * 0.55,
        t: 0,
        kind,
        size,
        spin: (Math.random()*16-8),
        rot: Math.random()*Math.PI*2,
      });
    }
  }
  function ring(x,y,r0, kind){
    particles.push({ x,y, vx:0, vy:0, life: 0.45, t:0, kind: kind+"_ring", r0 });
  }
  function addPopup(x, y, text, isCrit, colorKind = "gold") {
    popups.push({
      x, y,
      vy: -90 - Math.random() * 45,
      t: 0,
      life: 0.9,
      text,
      isCrit,
      colorKind,
      wob: Math.random()*10
    });
  }

  // ===== Cached Background (✅ 나무숲 + 잔디 업그레이드, 깔끔) =====
  const bgCanvas = document.createElement("canvas");
  bgCanvas.width = W;
  bgCanvas.height = H;
  const bg = bgCanvas.getContext("2d");

  function buildBackground(){
    bg.setTransform(1,0,0,1,0,0);
    bg.clearRect(0,0,W,H);

    // sky canopy
    const sky = bg.createLinearGradient(0,0,0,H);
    sky.addColorStop(0, "#0b2b1d");
    sky.addColorStop(0.35, "#0b1e26");
    sky.addColorStop(0.75, "#07101a");
    sky.addColorStop(1, "#05070d");
    bg.fillStyle = sky;
    bg.fillRect(0,0,W,H);

    // mist
    const mist = bg.createRadialGradient(W*0.52, H*0.18, 10, W*0.52, H*0.22, Math.max(W,H)*0.55);
    mist.addColorStop(0, "rgba(220,255,235,0.10)");
    mist.addColorStop(0.55, "rgba(160,220,255,0.06)");
    mist.addColorStop(1, "rgba(0,0,0,0)");
    bg.fillStyle = mist;
    bg.fillRect(0,0,W,H);

    // distant trees (layer 1)
    function drawTreeLayer(yBase, alpha, count, hueShift=0){
      bg.save();
      bg.globalAlpha = alpha;
      for(let i=0;i<count;i++){
        const x = bgRand()*W;
        const y = yBase + bgRand()* (H*0.22);
        const h = 140 + bgRand()*260;
        const w = 22 + bgRand()*40;

        // trunk
        bg.fillStyle = `rgba(${20+hueShift}, ${24+hueShift}, ${18}, 0.75)`;
        bg.beginPath();
        bg.ellipse(x, y, w*0.35, h*0.48, 0, 0, Math.PI*2);
        bg.fill();

        // canopy blob
        const rx = 70 + bgRand()*130;
        const ry = 50 + bgRand()*110;
        const g = bg.createRadialGradient(x-rx*0.15, y-h*0.45, 10, x, y-h*0.45, Math.max(rx,ry));
        g.addColorStop(0, "rgba(70,150,105,0.55)");
        g.addColorStop(1, "rgba(10,30,22,0)");
        bg.fillStyle = g;
        bg.beginPath();
        bg.ellipse(x, y-h*0.55, rx, ry, (bgRand()*0.8-0.4), 0, Math.PI*2);
        bg.fill();
      }
      bg.restore();
    }
    drawTreeLayer(H*0.05, 0.55, 22, 0);
    drawTreeLayer(H*0.10, 0.42, 18, 6);

    // light shafts (fixed)
    bg.save();
    bg.globalAlpha = 0.12;
    for(let i=0;i<8;i++){
      const x = bgRand()*W;
      const w = 90 + bgRand()*140;
      const grad = bg.createLinearGradient(x, 0, x+w, H);
      grad.addColorStop(0, "rgba(255,255,230,0)");
      grad.addColorStop(0.5, "rgba(255,255,230,0.40)");
      grad.addColorStop(1, "rgba(255,255,230,0)");
      bg.fillStyle = grad;
      bg.beginPath();
      bg.moveTo(x, 0);
      bg.lineTo(x+w, 0);
      bg.lineTo(x+w*0.62, H);
      bg.lineTo(x-w*0.08, H);
      bg.closePath();
      bg.fill();
    }
    bg.restore();

    // ground
    const groundY = H*0.50;
    const g0 = bg.createLinearGradient(0, groundY, 0, H);
    g0.addColorStop(0, "#1fa45a");
    g0.addColorStop(0.35, "#187a45");
    g0.addColorStop(0.75, "#0e4b2c");
    g0.addColorStop(1, "#09321e");
    bg.fillStyle = g0;
    bg.fillRect(0, groundY, W, H-groundY);

    // grass texture (fixed)
    bg.save();
    bg.globalAlpha = 0.22;
    for(let i=0;i<1400;i++){
      const x = bgRand()*W;
      const y = groundY + bgRand()*(H-groundY);
      const h = 5 + bgRand()*26;
      const w = 1 + bgRand()*2;
      bg.fillStyle = (i%4===0) ? "rgba(255,255,255,0.28)" : "rgba(0,0,0,0.22)";
      bg.fillRect(x, y, w, h);
    }
    bg.restore();

    // foreground bushes
    bg.save();
    bg.globalAlpha = 0.22;
    for(let i=0;i<26;i++){
      const x = bgRand()*W;
      const y = groundY + bgRand()*(H-groundY)*0.55;
      const rx = 50 + bgRand()*120;
      const ry = 24 + bgRand()*70;
      const gg = bg.createRadialGradient(x-rx*0.15, y-ry*0.2, 10, x, y, Math.max(rx,ry));
      gg.addColorStop(0, "rgba(110,200,140,0.65)");
      gg.addColorStop(1, "rgba(10,30,22,0)");
      bg.fillStyle = gg;
      bg.beginPath();
      bg.ellipse(x, y, rx, ry, bgRand()*1.0, 0, Math.PI*2);
      bg.fill();
    }
    bg.restore();

    // subtle foreground shade
    bg.save();
    bg.globalAlpha = 0.18;
    bg.fillStyle = "rgba(0,0,0,0.60)";
    bg.fillRect(0, H- Math.max(90, H*0.16), W, Math.max(90, H*0.16));
    bg.restore();
  }

  function drawVignette(g){
    const grad = g.createRadialGradient(W*0.5, H*0.40, 80, W*0.5, H*0.5, Math.max(W,H)*0.78);
    grad.addColorStop(0, "rgba(0,0,0,0)");
    grad.addColorStop(0.60, "rgba(0,0,0,0.08)");
    grad.addColorStop(1, "rgba(0,0,0,0.62)");
    g.fillStyle = grad;
    g.fillRect(0,0,W,H);
  }

  // ===== Coin / Hazard =====
  // ✅ “동그라미 제거”: 별만 + 글로우만
  function drawStarCoin(x, y, r, spinT = 0) {
    const tw = 0.85 + 0.15 * Math.sin(spinT * Math.PI * 2);
    const size = r * 2.05 * tw;

    // soft glow
    ctx.save();
    const g = ctx.createRadialGradient(x, y, r*0.2, x, y, r*2.6);
    g.addColorStop(0, "rgba(255,213,74,0.35)");
    g.addColorStop(0.55, "rgba(255,213,74,0.18)");
    g.addColorStop(1, "rgba(255,213,74,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r*2.6, 0, Math.PI*2);
    ctx.fill();

    // shadow
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(x+4, y+8, r*0.95, r*0.55, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    if (starImg.complete && starImg.naturalWidth) {
      ctx.drawImage(starImg, x - size/2, y - size/2, size, size);
    } else {
      // fallback star
      ctx.translate(x,y);
      ctx.fillStyle = "rgba(255,213,74,0.98)";
      ctx.beginPath();
      for (let i=0;i<10;i++){
        const ang = -Math.PI/2 + i*Math.PI/5;
        const rr = (i%2===0) ? r : r*0.45;
        ctx.lineTo(Math.cos(ang)*rr, Math.sin(ang)*rr);
      }
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawHazard(x, y, r, blinkT) {
    const blink = 0.55 + 0.45 * Math.sin(blinkT * Math.PI * 2);
    ctx.save();
    ctx.translate(x, y);

    const glow = ctx.createRadialGradient(0,0, r*0.2, 0,0, r*2.0);
    glow.addColorStop(0, `rgba(255,59,92,${0.55*blink})`);
    glow.addColorStop(0.35, `rgba(255,59,92,${0.22*blink})`);
    glow.addColorStop(1, "rgba(255,59,92,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0,0,r*2.0,0,Math.PI*2);
    ctx.fill();

    ctx.shadowColor = "rgba(0,0,0,0.35)";
    ctx.shadowBlur = 12;
    ctx.fillStyle = "rgba(255,59,92,0.95)";
    ctx.strokeStyle = "rgba(255,240,242,0.80)";
    ctx.lineWidth = 4;

    ctx.beginPath();
    const A = -Math.PI/2;
    const pts = [];
    for(let i=0;i<3;i++){
      const ang = A + i*(Math.PI*2/3);
      pts.push([Math.cos(ang)*r, Math.sin(ang)*r]);
    }
    const k = 0.22;
    ctx.moveTo(lerp(pts[0][0], pts[1][0], k), lerp(pts[0][1], pts[1][1], k));
    for(let i=0;i<3;i++){
      const p0 = pts[i];
      const p1 = pts[(i+1)%3];
      const p2 = pts[(i+2)%3];
      const a1x = lerp(p1[0], p0[0], k);
      const a1y = lerp(p1[1], p0[1], k);
      const a2x = lerp(p1[0], p2[0], k);
      const a2y = lerp(p1[1], p2[1], k);
      ctx.lineTo(a1x, a1y);
      ctx.quadraticCurveTo(p1[0], p1[1], a2x, a2y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(18,22,34,0.62)";
    ctx.beginPath();
    ctx.arc(0, r*0.12, r*0.44, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(0, r*0.05, r*0.22, 0, Math.PI*2);
    ctx.fill();
    ctx.fillRect(-r*0.14, r*0.18, r*0.28, r*0.16);

    ctx.fillStyle = "rgba(18,22,34,0.90)";
    ctx.beginPath();
    ctx.arc(-r*0.07, r*0.03, r*0.05, 0, Math.PI*2);
    ctx.arc( r*0.07, r*0.03, r*0.05, 0, Math.PI*2);
    ctx.fill();
    ctx.fillRect(-r*0.06, r*0.12, r*0.12, r*0.04);

    ctx.globalAlpha = 0.35 + 0.35*blink;
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, r*0.94, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Collisions =====
  function hitCircle(ax, ay, bx, by, br) {
    const dx = ax - bx;
    const dy = ay - by;
    return (dx * dx + dy * dy) <= (br * br);
  }

  // ===== Spawn =====
  function spawnEntities() {
    const cfg = DIFF[difficulty];
    coins = [];
    hazards = [];

    for (let i = 0; i < cfg.coins; i++) {
      const r = Math.round(Math.min(W,H) * 0.035) + i * 1.2;
      const points = i === cfg.coins - 1 ? 55 : (i === 0 ? 12 : 28);
      const core = Math.max(10, r * 0.55);
      coins.push({
        x: rnd(LEFT + r, RIGHT - r),
        y: rnd(TOP + r, BOTTOM - 170),
        r, core, points,
        vx: (Math.random()*260-130) * cfg.move,
        vy: (Math.random()*200-100) * cfg.move,
        spin: Math.random(),
        bob: Math.random()*10
      });
    }

    for (let i = 0; i < cfg.hazards; i++) {
      const r = Math.round(Math.min(W,H) * 0.030) + (i % 3);
      hazards.push({
        x: rnd(LEFT + r, RIGHT - r),
        y: rnd(TOP + r, BOTTOM - 130),
        r,
        vx: (Math.random()*340-170) * cfg.move,
        vy: (Math.random()*280-140) * cfg.move,
        blink: Math.random(),
      });
    }
  }

  // ===== Shooting =====
  function shoot() {
    if (!running) return;
    if (arrowCooldown > 0) return;

    const power = Math.max(1500, Math.min(W,H) * 2.7);
    let angle = aim.smooth;
    angle = clamp(angle, -Math.PI + 0.26, -0.23);

    const sp = power;
    const ax = Math.cos(angle);
    const ay = Math.sin(angle);

    arrows.push({
      x: player.x + ax * (player.r + 2),
      y: player.y + ay * (player.r + 2),
      vx: ax * sp,
      vy: ay * sp,
      rot: angle,
      alive: true,
      trail: [],
    });

    arrowCooldown = DIFF[difficulty].arrowCd;
    sfx.shoot();
  }

  // ===== Overlay / HUD =====
  function showStartOverlay() {
    ovTitle.textContent = "XGP 석궁 미니게임";
    ovDesc.innerHTML =
      `파워는 자동(항상 강함)이고 <b>조준만</b> 하면 됩니다.<br/>
       <span class="gold">별</span>을 맞추면 점수! 중앙(<b>별 중심</b>)을 맞추면 <span class="gold">크리티컬</span>!<br/>
       <span class="warn">⚠️ 위험 표식</span>을 맞추면 즉시 게임 오버!`;
    ovFinal.style.display = "none";
    startBtn.textContent = "START";
    overlay.style.display = "flex";
  }

  function gameOver(reason) {
    running = false;
    if (reason === "TIME") sfx.timeup();
    else sfx.boom();

    const rText = reason === "TIME" ? "시간 종료!" : "⚠️ 위험 표식을 맞췄습니다!";
    ovTitle.textContent = "GAME OVER";
    ovDesc.innerHTML = `<span class="warn">${rText}</span><br/>최종 점수와 최고기록을 확인하세요.`;

    ovFinal.style.display = "block";
    ovFinal.innerHTML = `최종 점수: <span class="gold">${score}</span><br/>최고 기록: <span class="gold">${best}</span>`;

    startBtn.textContent = "RETRY";
    overlay.style.display = "flex";
  }

  function updateHud() {
    timeText.textContent = remaining.toFixed(1);
    scoreText.textContent = String(score);
    bestText.textContent = String(best);
  }

  // ===== Game Flow =====
  function startRound() {
    ensureAudio();
    running = true;
    lastTs = performance.now();

    elapsed = 0;
    score = 0;
    remaining = DIFF[difficulty].time;

    arrows = [];
    particles = [];
    popups = [];
    arrowCooldown = 0;

    shakeT = 0; shakePow = 0;

    spawnEntities();
    updateHud();
    overlay.style.display = "none";
    requestAnimationFrame(loop);
  }

  function resetRoundToOverlay() {
    running = false;
    showStartOverlay();
  }

  // ===== Input =====
  canvas.addEventListener("pointerdown", (e) => {
    ensureAudio();
    updateAimFromPointer(e.clientX, e.clientY);
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointermove", (e) => updateAimFromPointer(e.clientX, e.clientY));
  canvas.addEventListener("pointerup", () => shoot());

  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight"," ","Space"].includes(e.key)) e.preventDefault();
    keys.add(e.key);
    if (e.key === " " || e.key === "Space") shoot();
    if (e.key === "r" || e.key === "R") resetRoundToOverlay();
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key));

  startBtn.addEventListener("click", () => startRound());
  resetBtn.addEventListener("click", () => resetRoundToOverlay());
  resetBtn2.addEventListener("click", () => resetRoundToOverlay());

  resetBestBtn.addEventListener("click", () => {
    localStorage.removeItem(BEST_KEY);
    best = 0;
    bestText.textContent = "0";
  });

  // ===== Loop =====
  function loop(ts) {
    if (!running) return;
    const dtMs = Math.max(0, Math.min(34, ts - lastTs));
    const dt = dtMs / 1000;
    lastTs = ts;

    update(dt, dtMs);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt, dtMs) {
    elapsed += dt;
    remaining = Math.max(0, DIFF[difficulty].time - elapsed);

    if (remaining <= 0) {
      if (score > best) {
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
      }
      updateHud();
      gameOver("TIME");
      return;
    }

    aim.smooth = lerp(aim.smooth, aim.angle, 1 - Math.pow(0.001, dt*60));
    aim.smooth = clamp(aim.smooth, -Math.PI + 0.26, -0.23);

    arrowCooldown = Math.max(0, arrowCooldown - dtMs);

    const left = keys.has("ArrowLeft") || keys.has("a") || keys.has("A");
    const right = keys.has("ArrowRight") || keys.has("d") || keys.has("D");
    if (left) aim.angle -= dt * 1.9;
    if (right) aim.angle += dt * 1.9;
    aim.angle = clamp(aim.angle, -Math.PI + 0.26, -0.23);

    const cfg = DIFF[difficulty];
    const wind = cfg.wind;

    for (const c of coins) {
      c.spin = (c.spin + dt * 0.9) % 1;
      c.bob += dt * 2.4;
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      if (c.x < LEFT + c.r) { c.x = LEFT + c.r; c.vx *= -1; }
      if (c.x > RIGHT - c.r) { c.x = RIGHT - c.r; c.vx *= -1; }
      if (c.y < TOP + c.r) { c.y = TOP + c.r; c.vy *= -1; }
      if (c.y > BOTTOM - c.r) { c.y = BOTTOM - c.r; c.vy *= -1; }
    }

    for (const h of hazards) {
      h.blink = (h.blink + dt * 1.5) % 1;
      h.x += h.vx * dt;
      h.y += h.vy * dt;
      if (h.x < LEFT + h.r) { h.x = LEFT + h.r; h.vx *= -1; }
      if (h.x > RIGHT - h.r) { h.x = RIGHT - h.r; h.vx *= -1; }
      if (h.y < TOP + h.r) { h.y = TOP + h.r; h.vy *= -1; }
      if (h.y > BOTTOM - h.r) { h.y = BOTTOM - h.r; h.vy *= -1; }
    }

    if (shakeT > 0) {
      shakeT = Math.max(0, shakeT - dt);
      shakePow = lerp(shakePow, 0, 1 - Math.pow(0.001, dt*60));
    }

    const g = 820;
    for (const ar of arrows) {
      ar.vy += g * dt;
      ar.vx += wind * dt * 38;

      ar.x += ar.vx * dt;
      ar.y += ar.vy * dt;

      ar.rot = Math.atan2(ar.vy, ar.vx);

      ar.trail.push([ar.x, ar.y]);
      if (ar.trail.length > 10) ar.trail.shift();

      if (ar.y > H + 90 || ar.x < -90 || ar.x > W + 90) ar.alive = false;
      if (!ar.alive) continue;

      for (const h of hazards) {
        if (hitCircle(ar.x, ar.y, h.x, h.y, h.r * 0.92)) {
          ar.alive = false;
          burst(h.x, h.y, 42, "red");
          ring(h.x,h.y,h.r*1.6,"red");
          addPopup(h.x, h.y - 6, "BOOM", true, "red");
          addShake(10, 0.20);

          if (score > best) {
            best = score;
            localStorage.setItem(BEST_KEY, String(best));
          }
          updateHud();
          gameOver("HAZARD");
          return;
        }
      }

      for (const c of coins) {
        const cy = c.y + Math.sin(c.bob) * 2.5;
        if (hitCircle(ar.x, ar.y, c.x, cy, c.r * 0.94)) {
          ar.alive = false;

          const crit = hitCircle(ar.x, ar.y, c.x, cy, c.core);
          let add = c.points;
          if (crit) add = Math.round(add * 2);
          add = Math.round(add * cfg.bonus);

          score += add;
          if (score > best) {
            best = score;
            localStorage.setItem(BEST_KEY, String(best));
          }

          burst(c.x, cy, crit ? 34 : 20, crit ? "gold" : "mint");
          ring(c.x,cy,c.r*(crit?1.9:1.5), crit ? "gold" : "mint");
          addPopup(c.x, cy - 6, `+${add}`, crit, "gold");
          addShake(crit ? 6 : 3, 0.12);

          if (crit) sfx.crit(); else sfx.hit();

          c.x = rnd(LEFT + c.r, RIGHT - c.r);
          c.y = rnd(TOP + c.r, BOTTOM - 170);
          c.vx = (Math.random()*300-150) * cfg.move;
          c.vy = (Math.random()*240-120) * cfg.move;
          c.spin = Math.random();
          c.bob = Math.random()*10;
          break;
        }
      }
    }
    arrows = arrows.filter(a => a.alive);

    for (const p of particles) {
      p.t += dt;
      if (p.kind.endsWith("_ring")) continue;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt * 2.0);
      p.vy *= (1 - dt * 2.0);
      p.rot += (p.spin || 0) * dt;
    }
    particles = particles.filter(p => p.t < p.life);

    for (const s of popups) {
      s.t += dt;
      s.y += s.vy * dt;
      s.vy *= (1 - dt * 2.1);
      s.x += Math.sin((s.t*6)+s.wob) * 0.35;
    }
    popups = popups.filter(s => s.t < s.life);

    updateHud();
  }

  function render() {
    ctx.save();
    if (shakeT > 0 && shakePow > 0.1) {
      const s = shakePow * (shakeT / 0.20);
      ctx.translate((Math.random()*2-1)*s, (Math.random()*2-1)*s);
    }

    // background
    ctx.drawImage(bgCanvas, 0, 0);

    // border
    ctx.save();
    ctx.strokeStyle = "rgba(255,210,120,0.14)";
    ctx.lineWidth = Math.max(2, Math.min(W,H) * 0.004);
    drawRoundedRect(LEFT, TOP, RIGHT - LEFT, BOTTOM - TOP, Math.max(14, Math.min(W,H)*0.03));
    ctx.stroke();
    ctx.restore();

    // hazards
    for (const h of hazards) drawHazard(h.x, h.y, h.r, h.blink);

    // coins (stars)
    for (const c of coins) {
      const cy = c.y + Math.sin(c.bob) * 2.5;
      drawStarCoin(c.x, cy, c.r, c.spin);
    }

    // popups
    for (const s of popups) {
      const a = 1 - (s.t / s.life);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.font = `${Math.max(13, Math.round(Math.min(W,H)*0.028))}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillText(s.text, s.x + 1, s.y + 2);

      ctx.fillStyle = (s.colorKind === "red")
        ? "rgba(255,59,92,0.98)"
        : (s.isCrit ? "rgba(255,213,74,0.98)" : "rgba(255,248,225,0.95)");
      ctx.fillText(s.text, s.x, s.y);

      if (s.isCrit && starImg.complete && starImg.naturalWidth) {
        ctx.globalAlpha = a * 0.85;
        const sz = Math.max(18, Math.round(Math.min(W,H)*0.05));
        ctx.drawImage(starImg, s.x - sz/2, s.y - sz*1.35, sz, sz);
      }
      ctx.restore();
    }

    // arrows + trail
    for (const ar of arrows) {
      ctx.save();
      for (let i=0;i<ar.trail.length;i++){
        const p = ar.trail[i];
        const alpha = (i / ar.trail.length) * 0.35;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "rgba(255,243,215,0.92)";
        ctx.fillRect(p[0], p[1], 3, 3);
      }
      ctx.restore();

      ctx.save();
      ctx.translate(ar.x, ar.y);
      ctx.rotate(ar.rot);

      ctx.fillStyle = "rgba(255,243,215,0.95)";
      ctx.fillRect(-18, -2, 28, 4);

      ctx.fillStyle = "rgba(255,213,74,0.98)";
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(23, -7);
      ctx.lineTo(23, 7);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(46,242,194,0.98)";
      ctx.fillRect(-25, -6, 4, 12);

      ctx.restore();
    }

    // particles
    for (const p of particles) {
      const a = 1 - (p.t / p.life);
      ctx.save();
      ctx.globalAlpha = a;

      if (p.kind.endsWith("_ring")) {
        const k = p.t / p.life;
        const rr = p.r0 * (0.7 + k*1.1);
        ctx.lineWidth = 3;
        ctx.strokeStyle =
          p.kind.startsWith("gold") ? `rgba(255,213,74,${0.8*a})` :
          p.kind.startsWith("red")  ? `rgba(255,59,92,${0.7*a})` :
                                      `rgba(46,242,194,${0.7*a})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, rr, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
        continue;
      }

      ctx.fillStyle =
        p.kind === "gold" ? "rgba(255,213,74,0.95)" :
        p.kind === "red"  ? "rgba(255,59,92,0.90)" :
        p.kind === "mint" ? "rgba(46,242,194,0.90)" :
                            "rgba(255,255,255,0.75)";

      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot || 0);
      const s = p.size || 3;
      ctx.fillRect(-s/2, -s/2, s, s);
      ctx.restore();
    }

    // player + crossbow
    drawPlayerAndCrossbow();

    drawVignette(ctx);
    ctx.restore();
  }

  function drawPlayerAndCrossbow(){
    // player base
    ctx.save();
    ctx.fillStyle = "rgba(46,242,194,0.16)";
    ctx.strokeStyle = "rgba(46,242,194,0.52)";
    ctx.lineWidth = Math.max(2, Math.min(W,H)*0.005);
    ctx.beginPath();
    ctx.arc(player.x, player.y, Math.max(14, Math.min(W,H)*0.03), 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // aim guide
    const ax = Math.cos(aim.smooth), ay = Math.sin(aim.smooth);
    const bx = player.x + ax * (Math.min(W,H)*0.12);
    const by = player.y + ay * (Math.min(W,H)*0.12);

    ctx.save();
    ctx.strokeStyle = "rgba(255,213,74,0.88)";
    ctx.lineWidth = Math.max(2, Math.min(W,H)*0.0045);
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(bx, by);
    ctx.stroke();

    ctx.globalAlpha = 0.52;
    ctx.strokeStyle = "rgba(255,243,215,0.36)";
    ctx.setLineDash([7, 7]);
    ctx.beginPath();
    ctx.moveTo(bx, by);
    ctx.lineTo(bx + ax * (Math.min(W,H)*0.46), by + ay * (Math.min(W,H)*0.46));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    // crossbow
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(aim.smooth);

    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(0,0,0,0.50)";
    ctx.beginPath();
    ctx.ellipse(Math.min(W,H)*0.05, Math.min(W,H)*0.04, Math.min(W,H)*0.12, Math.min(W,H)*0.045, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const scale = Math.min(W,H) / 1700; // 화면 크기에 따라 자동 스케일
    const iw = 720 * scale, ih = 420 * scale;

    if (crossbowImg.complete && crossbowImg.naturalWidth) {
      ctx.drawImage(crossbowImg, -iw*0.08, -ih*0.52, iw, ih);
    } else {
      ctx.strokeStyle = "rgba(255,213,74,0.92)";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(70, 0);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ===== Init =====
  resizeCanvasToStage();
  buildBackground();

  bestText.textContent = String(best);
  scoreText.textContent = "0";
  timeText.textContent = String(DIFF[difficulty].time.toFixed(1));
  showStartOverlay();

  diffButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      if (!running) timeText.textContent = String(DIFF[difficulty].time.toFixed(1));
    });
  });
})();
</script>
</body>
</html>
