<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <title>XGP 석궁 미니게임</title>
  <style>
    :root{
      --panel: rgba(10,14,22,.72);
      --panel2: rgba(10,14,22,.55);
      --line: rgba(255,255,255,.10);
      --gold: #ffd54a;
      --mint: #2ef2c2;
      --warn: #ff3b5c;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.64);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      min-height:100svh;
      display:grid;
      place-items:center;
      background: radial-gradient(1200px 700px at 50% 20%, #111b34 0%, #080b14 55%, #05070d 100%);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      overflow:hidden;
      padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right))
               max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
    }

    .wrap{
      width:min(980px, 96vw);
      height: min(720px, 92svh);
      display:grid;
      grid-template-rows:auto 1fr;
      gap:10px;
    }

    .topbar{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
    }
    .hud{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-weight:900; }
    .pill{
      display:flex; gap:8px; align-items:center;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      white-space:nowrap;
    }
    .pill b{color:rgba(255,255,255,.95)}
    .pill span{color:var(--muted); font-weight:800}

    .btns{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button{
      appearance:none; border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-weight:950;
      cursor:pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,.28);
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.18); }
    button:active{ transform: translateY(1px) scale(.99); }

    .diff{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      padding:6px 8px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .chip{
      padding:8px 10px;
      border-radius:999px;
      font-weight:950;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      cursor:pointer;
      transition: .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .chip.is-on{
      background: rgba(255,213,74,.16);
      border-color: rgba(255,213,74,.35);
      box-shadow: 0 10px 22px rgba(255,213,74,.08);
    }
    .hint{ color: rgba(255,255,255,.64); font-weight:850; margin-left:4px; font-size: 12px; }

    .stage{
      position:relative;
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      box-shadow: 0 20px 70px rgba(0,0,0,.45);
      width:100%;
      aspect-ratio: 16/9;
      max-height: calc(92svh - 88px);
      display:grid;
      place-items:center;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action: none;
      background: #070a10;
      image-rendering: auto;
    }

    .overlay{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background: radial-gradient(900px 500px at 50% 30%, rgba(0,0,0,.60) 0%, rgba(0,0,0,.82) 70%, rgba(0,0,0,.92) 100%);
      backdrop-filter: blur(7px);
    }
    .card{
      width:min(560px, 92%);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(18,22,34,.84), rgba(10,12,18,.84));
      box-shadow: 0 24px 90px rgba(0,0,0,.55);
      padding:18px 16px 16px;
    }
    .title{
      font-size:20px;
      font-weight:950;
      letter-spacing:.3px;
      margin:0 0 8px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:950;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,213,74,.32);
      background: rgba(255,213,74,.14);
      color: rgba(255,243,215,.96);
      font-size:12px;
      white-space:nowrap;
    }
    .desc{
      margin:0 0 12px;
      color: rgba(255,255,255,.78);
      line-height:1.45;
      font-weight:750;
    }
    .desc b{color: rgba(255,255,255,.95)}
    .desc .gold{color: rgba(255,213,74,.95); font-weight:950}
    .desc .warn{color: rgba(255,59,92,.95); font-weight:950}
    .final{
      margin:10px 0 14px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      font-weight:950;
      color: rgba(255,255,255,.86);
      line-height:1.55;
    }
    .final .gold{color: rgba(255,213,74,.95); font-weight:950}
    .actions{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
    }
    .actions .left{display:flex; gap:10px; flex-wrap:wrap}
    .note{ color: rgba(255,255,255,.58); font-size:12px; font-weight:800; }

    @media (max-width: 720px){
      body{
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      .wrap{
        width:100vw;
        height:100svh;
        padding:10px;
        gap:8px;
      }
      .topbar{
        padding:8px 10px;
        border-radius:16px;
      }
      .pill{
        padding:6px 8px;
        font-size:12px;
      }
      .diff{
        padding:5px 6px;
        gap:6px;
      }
      .chip{
        padding:7px 9px;
        font-size:12px;
        border-radius:999px;
      }
      .hint{display:none;}
      button{
        padding:8px 10px;
        font-size:12px;
        border-radius:12px;
      }
      .stage{
        max-height: none;
        height: calc(100svh - 96px);
        aspect-ratio: 16/9;
      }
      .card{padding:16px 14px}
      .title{font-size:18px}
      .note{font-size:11px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="hud">
        <div class="pill"><span>TIME</span> <b id="timeText">30.0</b></div>
        <div class="pill"><span>SCORE</span> <b id="scoreText">0</b></div>
        <div class="pill"><span>BEST</span> <b id="bestText">0</b></div>
        <div class="pill"><span>DIFF</span> <b id="diffText">EASY</b></div>
      </div>

      <div class="btns">
        <div class="diff">
          <div class="chip is-on" data-diff="EASY">EASY</div>
          <div class="chip" data-diff="NORMAL">NORMAL</div>
          <div class="chip" data-diff="HARD">HARD</div>
          <div class="hint" id="diffHint">EASY: 기본 속도</div>
        </div>
        <button id="resetBtn" title="R 키로도 가능">RESET</button>
        <button id="resetBestBtn">RESET BEST</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="game"></canvas>

      <div class="overlay" id="overlay">
        <div class="card">
          <div class="title">
            <span class="badge">XGP CROSSBOW RANGE</span>
            <span id="ovTitle">XGP 석궁 미니게임</span>
          </div>
          <p class="desc" id="ovDesc"></p>
          <div class="final" id="ovFinal" style="display:none"></div>
          <div class="actions">
            <div class="left">
              <button id="startBtn">START</button>
              <button id="resetBtn2">CLOSE</button>
            </div>
            <div class="note">드래그/이동 조준 → 떼면 발사 / Space 발사 / R 리셋</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== DOM =====
  const canvas = document.getElementById("game");
  const stageEl = document.getElementById("stage");

  // ✅ 갤럭시(특히 삼성 브라우저/크롬) “빤짝임/깨짐” 방지:
  // - desynchronized 옵션 제거(일부 기기에서 프레임 플리커 유발 사례)
  // - SVG filter/dropShadow 제거(별/석궁을 캔버스 프리렌더링으로 대체)
  const ctx = canvas.getContext("2d", { alpha: true });

  ctx.imageSmoothingEnabled = true;

  const timeText = document.getElementById("timeText");
  const scoreText = document.getElementById("scoreText");
  const bestText = document.getElementById("bestText");
  const diffText = document.getElementById("diffText");

  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const resetBestBtn = document.getElementById("resetBestBtn");
  const resetBtn = document.getElementById("resetBtn");
  const resetBtn2 = document.getElementById("resetBtn2");

  const ovTitle = document.getElementById("ovTitle");
  const ovDesc = document.getElementById("ovDesc");
  const ovFinal = document.getElementById("ovFinal");

  const diffHint = document.getElementById("diffHint");
  const diffButtons = [...document.querySelectorAll(".chip")];

  // ===== Utils =====
  let W = 960, H = 540;
  let DPR = 1;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  // playfield
  let TOP = 88, BOTTOM = H - 108, LEFT = 26, RIGHT = W - 26;

  // ===== Stable RNG =====
  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  const bgRand = mulberry32(0xC0FFEE);
  const fxRand = mulberry32(0xBADA55);

  function drawRoundedRect(x, y, w, h, r) {
    r = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function canvasToLocal(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const sx = (clientX - rect.left) / rect.width;
    const sy = (clientY - rect.top) / rect.height;
    return { x: sx * W, y: sy * H };
  }

  // ✅ DPR resize (선명 + 좌표 정확 + 기기별 스케일 플리커 최소화)
  const bgCanvas = document.createElement("canvas");
  const bg = bgCanvas.getContext("2d");
  let bgBuilt = false;

  function resizeCanvasToStage(){
    const rect = stageEl.getBoundingClientRect();

    // 너무 높은 DPR이 오히려 깜빡임/열/프레임드랍 유발 -> 상한 제한
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    const targetW = Math.max(320, Math.round(rect.width * DPR));
    const targetH = Math.max(180, Math.round(rect.height * DPR));

    if (canvas.width !== targetW || canvas.height !== targetH){
      canvas.width = targetW;
      canvas.height = targetH;

      W = canvas.width;
      H = canvas.height;

      TOP = Math.round(H * 0.16);
      BOTTOM = Math.round(H * 0.80);
      LEFT = Math.round(W * 0.03);
      RIGHT = Math.round(W * 0.97);

      player.x = W * 0.5;
      player.y = H * 0.86;

      // background resize + rebuild
      bgCanvas.width = W;
      bgCanvas.height = H;
      buildBackground();
      buildStarSkins();  // 스킨도 화면해상도에 맞게 새로 프리렌더
      bgBuilt = true;

      // 레인/안개 파티클도 스케일에 맞게 다시 세팅
      initWeather();
    }
  }
  window.addEventListener("resize", () => resizeCanvasToStage(), { passive: true });

  // ===== Audio (no files) =====
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
  }
  function beep({ type="square", f0=700, f1=420, dur=0.08, gain=0.06, curve="exp" }) {
    try {
      ensureAudio();
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;

      o.frequency.setValueAtTime(f0, t);
      if (curve === "exp") o.frequency.exponentialRampToValueAtTime(Math.max(40, f1), t + dur);
      else o.frequency.linearRampToValueAtTime(f1, t + dur);

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      o.connect(g); g.connect(audioCtx.destination);
      o.start(t); o.stop(t + dur + 0.02);
    } catch {}
  }
  const sfx = {
    shoot() { beep({ type:"square", f0:720, f1:280, dur:0.07, gain:0.05 }); },
    hit()   { beep({ type:"triangle", f0:980, f1:560, dur:0.09, gain:0.06 }); },
    crit()  { beep({ type:"sawtooth", f0:1500, f1:740, dur:0.11, gain:0.065 }); },
    boom()  { beep({ type:"sawtooth", f0:220, f1:65, dur:0.15, gain:0.075, curve:"lin" }); },
    timeup(){ beep({ type:"triangle", f0:420, f1:140, dur:0.19, gain:0.06 }); },
  };

  // ===== Difficulty =====
  const DIFF = {
    EASY:   { coins: 3, hazards: 4, move: 1.00, wind: 0.0, arrowCd: 190, bonus: 1.00, time: 30 },
    NORMAL: { coins: 4, hazards: 6, move: 1.25, wind: 1.0, arrowCd: 230, bonus: 1.08, time: 30 },
    HARD:   { coins: 5, hazards: 8, move: 1.50, wind: 1.8, arrowCd: 280, bonus: 1.15, time: 30 },
  };
  const DIFF_HINTS = {
    EASY:   "EASY: 기본 속도",
    NORMAL: "NORMAL: 더 빠름 + 바람",
    HARD:   "HARD: 매우 빠름 + 강한 바람",
  };

  let difficulty = "EASY";
  function setDifficulty(d) {
    difficulty = d;
    diffButtons.forEach(b => b.classList.toggle("is-on", b.dataset.diff === d));
    if (diffHint) diffHint.textContent = DIFF_HINTS[d] || "";
    diffText.textContent = d;
  }
  diffButtons.forEach(btn => btn.addEventListener("click", () => setDifficulty(btn.dataset.diff)));
  setDifficulty("EASY");

  // ===== Best =====
  const BEST_KEY = "xgp_crossbow_best_v9";
  let best = Number(localStorage.getItem(BEST_KEY) || 0);

  // ===== Crossbow (SVG → bitmap) =====
  // ✅ 깜빡임 방지 위해 SVG 필터 없이 간단+고급 느낌의 벡터를 "이미지"로 사용
  function svgToImg(svg) {
    const img = new Image();
    img.decoding = "async";
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg.trim());
    return img;
  }
  const crossbowImg = svgToImg(`
  <svg xmlns="http://www.w3.org/2000/svg" width="720" height="420" viewBox="0 0 720 420">
    <defs>
      <linearGradient id="woodA" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#a76b35"/>
        <stop offset="0.45" stop-color="#7a4520"/>
        <stop offset="1" stop-color="#3b1d0b"/>
      </linearGradient>
      <linearGradient id="woodB" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0" stop-color="#d59a5a"/>
        <stop offset="0.35" stop-color="#9b5a2a"/>
        <stop offset="1" stop-color="#5a2a10"/>
      </linearGradient>
      <linearGradient id="gold" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#fff3c8"/>
        <stop offset="0.35" stop-color="#ffd54a"/>
        <stop offset="1" stop-color="#c57a00"/>
      </linearGradient>
      <radialGradient id="shine" cx="30%" cy="25%" r="70%">
        <stop offset="0" stop-color="#ffffff" stop-opacity="0.38"/>
        <stop offset="0.35" stop-color="#ffffff" stop-opacity="0.12"/>
        <stop offset="1" stop-color="#ffffff" stop-opacity="0"/>
      </radialGradient>
    </defs>

    <g transform="translate(26,24)">
      <path d="M270 250
               C225 305,212 352,236 370
               C270 392,330 350,360 318
               C400 274,412 260,438 258
               C470 255,500 278,522 270
               C552 258,572 230,564 206
               C552 168,502 164,478 186
               C458 204,436 196,412 176
               C368 140,318 170,300 192
               C288 206,286 230,270 250 Z"
            fill="url(#woodA)" stroke="#1a0c05" stroke-width="8" />

      <path d="M302 232 C275 272,266 342,296 360"
            fill="none" stroke="rgba(255,235,200,.22)" stroke-width="10" stroke-linecap="round"/>

      <path d="M310 120 L560 210 L534 250 L286 158 Z"
            fill="url(#woodB)" stroke="#241107" stroke-width="8" />

      <rect x="308" y="172" width="82" height="74" rx="14"
            fill="#2a1408" stroke="#140903" stroke-width="8"/>
      <path d="M348 220 C342 246,360 270,384 278"
            fill="none" stroke="#0c0502" stroke-width="10" stroke-linecap="round"/>

      <path d="M88 92 C210 80,290 120,326 148"
            fill="none" stroke="#2b1408" stroke-width="26" stroke-linecap="round"/>
      <path d="M120 320 C224 280,284 214,326 148"
            fill="none" stroke="#2b1408" stroke-width="26" stroke-linecap="round"/>

      <path d="M102 92 L126 320" stroke="rgba(255,245,220,.95)" stroke-width="4" stroke-linecap="round"/>
      <path d="M102 92 L126 320" stroke="rgba(0,0,0,.22)" stroke-width="7" stroke-linecap="round"/>

      <path d="M324 150 L586 236" stroke="rgba(255,245,220,.95)" stroke-width="10" stroke-linecap="round"/>
      <path d="M560 228 L624 250" stroke="rgba(46,242,194,.95)" stroke-width="12" stroke-linecap="round"/>
      <path d="M588 238 L652 218 L652 280 Z" fill="url(#gold)" stroke="#4a2300" stroke-width="8"/>

      <circle cx="404" cy="214" r="10" fill="url(#gold)" stroke="#4a2300" stroke-width="6"/>
      <circle cx="468" cy="236" r="10" fill="url(#gold)" stroke="#4a2300" stroke-width="6"/>

      <ellipse cx="420" cy="190" rx="300" ry="220" fill="url(#shine)"/>
    </g>
  </svg>`);

  // ===== Star skins (✅ 2~3종 랜덤, 캔버스에 프리렌더 → 플리커 방지) =====
  const starSkins = []; // each: {canvas, size}
  function buildStarSkins(){
    starSkins.length = 0;
    const base = Math.max(72, Math.round(Math.min(W,H) * 0.16)); // 프리렌더 사이즈

    function makeSkin({fillA, fillB, stroke, glA, glB, sparkle, name}){
      const c = document.createElement("canvas");
      c.width = base;
      c.height = base;
      const g = c.getContext("2d");
      g.imageSmoothingEnabled = true;

      const cx = base/2, cy = base/2;
      const R = base*0.37, r = base*0.17;

      // soft glow
      const glow = g.createRadialGradient(cx, cy, base*0.05, cx, cy, base*0.48);
      glow.addColorStop(0, glA);
      glow.addColorStop(0.6, glB);
      glow.addColorStop(1, "rgba(0,0,0,0)");
      g.fillStyle = glow;
      g.beginPath();
      g.arc(cx, cy, base*0.48, 0, Math.PI*2);
      g.fill();

      // drop shadow (very mild, no blur flicker: blur small + fixed)
      g.save();
      g.globalAlpha = 0.35;
      g.fillStyle = "rgba(0,0,0,0.55)";
      g.beginPath();
      g.ellipse(cx+base*0.03, cy+base*0.09, base*0.26, base*0.13, 0, 0, Math.PI*2);
      g.fill();
      g.restore();

      // star path
      g.beginPath();
      for(let i=0;i<10;i++){
        const ang = -Math.PI/2 + i*Math.PI/5;
        const rr = (i%2===0) ? R : r;
        const x = cx + Math.cos(ang)*rr;
        const y = cy + Math.sin(ang)*rr;
        if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
      }
      g.closePath();

      // star fill gradient
      const grad = g.createRadialGradient(cx-base*0.10, cy-base*0.12, base*0.06, cx, cy, base*0.46);
      grad.addColorStop(0, fillA);
      grad.addColorStop(1, fillB);
      g.fillStyle = grad;
      g.fill();

      g.strokeStyle = stroke;
      g.lineWidth = Math.max(3, base*0.045);
      g.lineJoin = "round";
      g.stroke();

      // inner highlight
      g.save();
      g.globalAlpha = 0.25;
      g.fillStyle = "rgba(255,255,255,0.9)";
      g.beginPath();
      g.ellipse(cx-base*0.07, cy-base*0.08, base*0.09, base*0.22, -0.35, 0, Math.PI*2);
      g.fill();
      g.restore();

      // sparkles (fixed positions)
      g.save();
      g.globalAlpha = 0.55;
      g.fillStyle = sparkle;
      const pts = [
        [0.22,0.28],[0.66,0.22],[0.75,0.62],[0.28,0.72],[0.52,0.78]
      ];
      for(const [px,py] of pts){
        g.fillRect(base*px, base*py, 2, 2);
        g.fillRect(base*px+4, base*py+2, 1, 1);
      }
      g.restore();

      starSkins.push({ canvas:c, size:base, name });
    }

    // GOLD (classic)
    makeSkin({
      name:"GOLD",
      fillA:"rgba(255,252,235,0.98)",
      fillB:"rgba(240,168,0,0.98)",
      stroke:"rgba(255,245,210,0.92)",
      glA:"rgba(255,213,74,0.35)",
      glB:"rgba(255,213,74,0.14)",
      sparkle:"rgba(255,255,255,0.85)"
    });

    // ICE (silver-blue)
    makeSkin({
      name:"ICE",
      fillA:"rgba(245,252,255,0.98)",
      fillB:"rgba(120,200,255,0.98)",
      stroke:"rgba(220,245,255,0.92)",
      glA:"rgba(160,220,255,0.30)",
      glB:"rgba(160,220,255,0.12)",
      sparkle:"rgba(240,255,255,0.85)"
    });

    // EMERALD (green)
    makeSkin({
      name:"EMERALD",
      fillA:"rgba(240,255,250,0.98)",
      fillB:"rgba(46,242,194,0.98)",
      stroke:"rgba(215,255,245,0.92)",
      glA:"rgba(46,242,194,0.26)",
      glB:"rgba(46,242,194,0.10)",
      sparkle:"rgba(240,255,250,0.85)"
    });
  }

  // ===== Weather (✅ 비 + 안개 애니메이션, 깔끔/저부하) =====
  let rain = [];
  let fog = [];
  function initWeather(){
    rain = [];
    fog = [];

    const countRain = Math.round((W*H) / (900000 / DPR)); // 해상도 따라 자연스럽게
    const countFog  = Math.round((W*H) / (1400000 / DPR));

    for(let i=0;i<countRain;i++){
      rain.push({
        x: fxRand()*W,
        y: fxRand()*H,
        v: 700 + fxRand()*900,
        len: 14 + fxRand()*22,
        w: 1 + fxRand()*1.2,
        drift: -40 - fxRand()*70
      });
    }
    for(let i=0;i<countFog;i++){
      fog.push({
        x: fxRand()*W,
        y: H*(0.05 + fxRand()*0.55),
        r: (Math.min(W,H) * (0.08 + fxRand()*0.14)),
        vx: (fxRand()*2-1) * (18 + fxRand()*26),
        vy: (fxRand()*2-1) * (4 + fxRand()*8),
        a: 0.04 + fxRand()*0.06
      });
    }
  }

  function updateWeather(dt){
    // rain
    for(const d of rain){
      d.x += d.drift * dt;
      d.y += d.v * dt;
      if(d.y > H + 40){
        d.y = -40 - fxRand()*200;
        d.x = fxRand()*W;
      }
      if(d.x < -80){
        d.x = W + fxRand()*80;
      }
    }
    // fog
    for(const f of fog){
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      if(f.x < -f.r*2) f.x = W + f.r*2;
      if(f.x > W + f.r*2) f.x = -f.r*2;
      // y 범위만 살짝 유지
      const yMin = H*0.02, yMax = H*0.62;
      if(f.y < yMin) f.y = yMin;
      if(f.y > yMax) f.y = yMax;
    }
  }

  function renderWeather(){
    // fog first (behind gameplay elements 느낌)
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    for(const f of fog){
      const g = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.r);
      g.addColorStop(0, `rgba(220,255,235,${f.a})`);
      g.addColorStop(0.55, `rgba(170,220,255,${f.a*0.7})`);
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // rain on top (very subtle, no flashing)
    ctx.save();
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineCap = "round";
    for(const d of rain){
      ctx.lineWidth = d.w;
      ctx.beginPath();
      ctx.moveTo(d.x, d.y);
      ctx.lineTo(d.x + d.drift*0.035, d.y + d.len);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ===== Background (forest/grass) =====
  function buildBackground(){
    bg.setTransform(1,0,0,1,0,0);
    bg.clearRect(0,0,W,H);

    const sky = bg.createLinearGradient(0,0,0,H);
    sky.addColorStop(0, "#0b2b1d");
    sky.addColorStop(0.35, "#0b1e26");
    sky.addColorStop(0.75, "#07101a");
    sky.addColorStop(1, "#05070d");
    bg.fillStyle = sky;
    bg.fillRect(0,0,W,H);

    const mist = bg.createRadialGradient(W*0.52, H*0.18, 10, W*0.52, H*0.22, Math.max(W,H)*0.55);
    mist.addColorStop(0, "rgba(220,255,235,0.10)");
    mist.addColorStop(0.55, "rgba(160,220,255,0.06)");
    mist.addColorStop(1, "rgba(0,0,0,0)");
    bg.fillStyle = mist;
    bg.fillRect(0,0,W,H);

    function drawTreeLayer(yBase, alpha, count){
      bg.save();
      bg.globalAlpha = alpha;
      for(let i=0;i<count;i++){
        const x = bgRand()*W;
        const y = yBase + bgRand()* (H*0.22);
        const h = 140 + bgRand()*260;
        const w = 22 + bgRand()*40;

        bg.fillStyle = `rgba(16, 20, 16, 0.78)`;
        bg.beginPath();
        bg.ellipse(x, y, w*0.35, h*0.48, 0, 0, Math.PI*2);
        bg.fill();

        const rx = 70 + bgRand()*130;
        const ry = 50 + bgRand()*110;
        const g = bg.createRadialGradient(x-rx*0.15, y-h*0.45, 10, x, y-h*0.45, Math.max(rx,ry));
        g.addColorStop(0, "rgba(70,150,105,0.55)");
        g.addColorStop(1, "rgba(10,30,22,0)");
        bg.fillStyle = g;
        bg.beginPath();
        bg.ellipse(x, y-h*0.55, rx, ry, (bgRand()*0.8-0.4), 0, Math.PI*2);
        bg.fill();
      }
      bg.restore();
    }
    drawTreeLayer(H*0.05, 0.55, 22);
    drawTreeLayer(H*0.10, 0.42, 18);

    // fixed light shafts
    bg.save();
    bg.globalAlpha = 0.10;
    for(let i=0;i<8;i++){
      const x = bgRand()*W;
      const w = 90 + bgRand()*140;
      const grad = bg.createLinearGradient(x, 0, x+w, H);
      grad.addColorStop(0, "rgba(255,255,230,0)");
      grad.addColorStop(0.5, "rgba(255,255,230,0.40)");
      grad.addColorStop(1, "rgba(255,255,230,0)");
      bg.fillStyle = grad;
      bg.beginPath();
      bg.moveTo(x, 0);
      bg.lineTo(x+w, 0);
      bg.lineTo(x+w*0.62, H);
      bg.lineTo(x-w*0.08, H);
      bg.closePath();
      bg.fill();
    }
    bg.restore();

    const groundY = H*0.50;
    const g0 = bg.createLinearGradient(0, groundY, 0, H);
    g0.addColorStop(0, "#1fa45a");
    g0.addColorStop(0.35, "#187a45");
    g0.addColorStop(0.75, "#0e4b2c");
    g0.addColorStop(1, "#09321e");
    bg.fillStyle = g0;
    bg.fillRect(0, groundY, W, H-groundY);

    // grass texture
    bg.save();
    bg.globalAlpha = 0.22;
    for(let i=0;i<1400;i++){
      const x = bgRand()*W;
      const y = groundY + bgRand()*(H-groundY);
      const h = 5 + bgRand()*26;
      const w = 1 + bgRand()*2;
      bg.fillStyle = (i%4===0) ? "rgba(255,255,255,0.28)" : "rgba(0,0,0,0.22)";
      bg.fillRect(x, y, w, h);
    }
    bg.restore();

    // foreground bushes
    bg.save();
    bg.globalAlpha = 0.22;
    for(let i=0;i<26;i++){
      const x = bgRand()*W;
      const y = groundY + bgRand()*(H-groundY)*0.55;
      const rx = 50 + bgRand()*120;
      const ry = 24 + bgRand()*70;
      const gg = bg.createRadialGradient(x-rx*0.15, y-ry*0.2, 10, x, y, Math.max(rx,ry));
      gg.addColorStop(0, "rgba(110,200,140,0.65)");
      gg.addColorStop(1, "rgba(10,30,22,0)");
      bg.fillStyle = gg;
      bg.beginPath();
      bg.ellipse(x, y, rx, ry, bgRand()*1.0, 0, Math.PI*2);
      bg.fill();
    }
    bg.restore();

    bg.save();
    bg.globalAlpha = 0.18;
    bg.fillStyle = "rgba(0,0,0,0.60)";
    bg.fillRect(0, H- Math.max(90, H*0.16), W, Math.max(90, H*0.16));
    bg.restore();
  }

  function drawVignette(g){
    const grad = g.createRadialGradient(W*0.5, H*0.40, 80, W*0.5, H*0.5, Math.max(W,H)*0.78);
    grad.addColorStop(0, "rgba(0,0,0,0)");
    grad.addColorStop(0.60, "rgba(0,0,0,0.08)");
    grad.addColorStop(1, "rgba(0,0,0,0.62)");
    g.fillStyle = grad;
    g.fillRect(0,0,W,H);
  }

  // ===== Game State =====
  let running = false;
  let lastTs = 0;

  let elapsed = 0;
  let score = 0;
  let remaining = DIFF[difficulty].time;

  const player = { x: W / 2, y: H * 0.86, r: 18 };
  const aim = { angle: -Math.PI / 2, smooth: -Math.PI / 2 };

  let arrows = [];
  let coins = [];
  let hazards = [];
  let particles = [];
  let popups = [];

  let arrowCooldown = 0;

  // ✅ 화면 “빤짝임” 줄이기 위해 랜덤 shake 대신 “연속 사인” shake
  let shakeT = 0;
  let shakePow = 0;
  let shakePhase = 0;

  // ===== Helpers =====
  function rnd(min, max) { return min + Math.random() * (max - min); }

  function updateAimFromPointer(clientX, clientY) {
    const p = canvasToLocal(clientX, clientY);
    const dx = p.x - player.x;
    const dy = p.y - player.y;
    if (dy > 0) return;
    aim.angle = Math.atan2(dy, dx);
    aim.angle = clamp(aim.angle, -Math.PI + 0.26, -0.23);
  }
  function addShake(pow, t=0.16){
    shakePow = Math.max(shakePow, pow);
    shakeT = Math.max(shakeT, t);
  }

  // ===== FX =====
  function burst(x, y, n, kind) {
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const s = 90 + Math.random() * 240;
      const size = 2 + Math.random() * 3;
      particles.push({
        x, y,
        vx: Math.cos(a) * s,
        vy: Math.sin(a) * s,
        life: 0.35 + Math.random() * 0.55,
        t: 0,
        kind,
        size,
        spin: (Math.random()*16-8),
        rot: Math.random()*Math.PI*2,
      });
    }
  }
  function ring(x,y,r0, kind){
    particles.push({ x,y, vx:0, vy:0, life: 0.45, t:0, kind: kind+"_ring", r0 });
  }
  function addPopup(x, y, text, isCrit, colorKind = "gold") {
    popups.push({
      x, y,
      vy: -90 - Math.random() * 45,
      t: 0,
      life: 0.9,
      text,
      isCrit,
      colorKind,
      wob: Math.random()*10
    });
  }

  // ===== Drawing: Stars / Hazards =====
  function drawStarCoin(c) {
    const { x, y, r, skin, spin, bob } = c;
    const cy = y + Math.sin(bob) * 2.5;
    const tw = 0.86 + 0.14 * Math.sin(spin * Math.PI * 2);

    // super soft glow (stable)
    ctx.save();
    const g = ctx.createRadialGradient(x, cy, r*0.2, x, cy, r*2.4);
    g.addColorStop(0, "rgba(255,213,74,0.22)");
    g.addColorStop(0.65, "rgba(255,213,74,0.10)");
    g.addColorStop(1, "rgba(255,213,74,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, cy, r*2.4, 0, Math.PI*2);
    ctx.fill();

    // bitmap star skin
    const s = r * 2.1 * tw;
    const img = starSkins[skin % starSkins.length]?.canvas;
    if (img) {
      ctx.drawImage(img, x - s/2, cy - s/2, s, s);
    } else {
      // fallback
      ctx.translate(x, cy);
      ctx.fillStyle = "rgba(255,213,74,0.98)";
      ctx.beginPath();
      for (let i=0;i<10;i++){
        const ang = -Math.PI/2 + i*Math.PI/5;
        const rr = (i%2===0) ? r : r*0.45;
        ctx.lineTo(Math.cos(ang)*rr, Math.sin(ang)*rr);
      }
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawHazard(x, y, r, blinkT) {
    const blink = 0.55 + 0.45 * Math.sin(blinkT * Math.PI * 2);
    ctx.save();
    ctx.translate(x, y);

    const glow = ctx.createRadialGradient(0,0, r*0.2, 0,0, r*2.0);
    glow.addColorStop(0, `rgba(255,59,92,${0.45*blink})`);
    glow.addColorStop(0.35, `rgba(255,59,92,${0.18*blink})`);
    glow.addColorStop(1, "rgba(255,59,92,0)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0,0,r*2.0,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,59,92,0.95)";
    ctx.strokeStyle = "rgba(255,240,242,0.78)";
    ctx.lineWidth = Math.max(3, r*0.20);

    ctx.beginPath();
    const A = -Math.PI/2;
    const pts = [];
    for(let i=0;i<3;i++){
      const ang = A + i*(Math.PI*2/3);
      pts.push([Math.cos(ang)*r, Math.sin(ang)*r]);
    }
    const k = 0.22;
    ctx.moveTo(lerp(pts[0][0], pts[1][0], k), lerp(pts[0][1], pts[1][1], k));
    for(let i=0;i<3;i++){
      const p0 = pts[i];
      const p1 = pts[(i+1)%3];
      const p2 = pts[(i+2)%3];
      const a1x = lerp(p1[0], p0[0], k);
      const a1y = lerp(p1[1], p0[1], k);
      const a2x = lerp(p1[0], p2[0], k);
      const a2y = lerp(p1[1], p2[1], k);
      ctx.lineTo(a1x, a1y);
      ctx.quadraticCurveTo(p1[0], p1[1], a2x, a2y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.globalAlpha = 0.32 + 0.28*blink;
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, r*0.94, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  // ===== Collisions =====
  function hitCircle(ax, ay, bx, by, br) {
    const dx = ax - bx;
    const dy = ay - by;
    return (dx * dx + dy * dy) <= (br * br);
  }

  // ===== Spawn =====
  function spawnEntities() {
    const cfg = DIFF[difficulty];
    coins = [];
    hazards = [];

    for (let i = 0; i < cfg.coins; i++) {
      const r = Math.round(Math.min(W,H) * 0.035) + i * 1.2;
      const points = i === cfg.coins - 1 ? 55 : (i === 0 ? 12 : 28);
      const core = Math.max(10, r * 0.55);
      coins.push({
        x: rnd(LEFT + r, RIGHT - r),
        y: rnd(TOP + r, BOTTOM - 170),
        r, core, points,
        vx: (Math.random()*260-130) * cfg.move,
        vy: (Math.random()*200-100) * cfg.move,
        spin: Math.random(),
        bob: Math.random()*10,
        skin: (Math.random()*starSkins.length) | 0, // ✅ 랜덤 스킨
      });
    }

    for (let i = 0; i < cfg.hazards; i++) {
      const r = Math.round(Math.min(W,H) * 0.030) + (i % 3);
      hazards.push({
        x: rnd(LEFT + r, RIGHT - r),
        y: rnd(TOP + r, BOTTOM - 130),
        r,
        vx: (Math.random()*340-170) * cfg.move,
        vy: (Math.random()*280-140) * cfg.move,
        blink: Math.random(),
      });
    }
  }

  // ===== Shooting =====
  function shoot() {
    if (!running) return;
    if (arrowCooldown > 0) return;

    const power = Math.max(1500, Math.min(W,H) * 2.7);
    let angle = aim.smooth;
    angle = clamp(angle, -Math.PI + 0.26, -0.23);

    const ax = Math.cos(angle);
    const ay = Math.sin(angle);

    arrows.push({
      x: player.x + ax * (player.r + 2),
      y: player.y + ay * (player.r + 2),
      vx: ax * power,
      vy: ay * power,
      rot: angle,
      alive: true,
      trail: [],
    });

    arrowCooldown = DIFF[difficulty].arrowCd;
    sfx.shoot();
  }

  // ===== Overlay / HUD =====
  function showStartOverlay() {
    ovTitle.textContent = "XGP 석궁 미니게임";
    ovDesc.innerHTML =
      `파워는 자동(항상 강함)이고 <b>조준만</b> 하면 됩니다.<br/>
       <span class="gold">별</span>을 맞추면 점수! 중앙(<b>별 중심</b>)을 맞추면 <span class="gold">크리티컬</span>!<br/>
       <span class="warn">⚠️ 위험 표식</span>을 맞추면 즉시 게임 오버!`;
    ovFinal.style.display = "none";
    startBtn.textContent = "START";
    overlay.style.display = "flex";
  }

  function gameOver(reason) {
    running = false;
    if (reason === "TIME") sfx.timeup();
    else sfx.boom();

    const rText = reason === "TIME" ? "시간 종료!" : "⚠️ 위험 표식을 맞췄습니다!";
    ovTitle.textContent = "GAME OVER";
    ovDesc.innerHTML = `<span class="warn">${rText}</span><br/>최종 점수와 최고기록을 확인하세요.`;

    ovFinal.style.display = "block";
    ovFinal.innerHTML = `최종 점수: <span class="gold">${score}</span><br/>최고 기록: <span class="gold">${best}</span>`;

    startBtn.textContent = "RETRY";
    overlay.style.display = "flex";
  }

  function updateHud() {
    timeText.textContent = remaining.toFixed(1);
    scoreText.textContent = String(score);
    bestText.textContent = String(best);
  }

  // ===== Game Flow =====
  function startRound() {
    ensureAudio();
    running = true;
    lastTs = performance.now();

    elapsed = 0;
    score = 0;
    remaining = DIFF[difficulty].time;

    arrows = [];
    particles = [];
    popups = [];
    arrowCooldown = 0;

    shakeT = 0; shakePow = 0; shakePhase = 0;

    spawnEntities();
    updateHud();
    overlay.style.display = "none";
    requestAnimationFrame(loop);
  }

  function resetRoundToOverlay() {
    running = false;
    showStartOverlay();
  }

  // ===== Input =====
  canvas.addEventListener("pointerdown", (e) => {
    ensureAudio();
    updateAimFromPointer(e.clientX, e.clientY);
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointermove", (e) => updateAimFromPointer(e.clientX, e.clientY));
  canvas.addEventListener("pointerup", () => shoot());

  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight"," ","Space"].includes(e.key)) e.preventDefault();
    keys.add(e.key);
    if (e.key === " " || e.key === "Space") shoot();
    if (e.key === "r" || e.key === "R") resetRoundToOverlay();
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key));

  startBtn.addEventListener("click", () => startRound());
  resetBtn.addEventListener("click", () => resetRoundToOverlay());
  resetBtn2.addEventListener("click", () => resetRoundToOverlay());

  resetBestBtn.addEventListener("click", () => {
    localStorage.removeItem(BEST_KEY);
    best = 0;
    bestText.textContent = "0";
  });

  // ===== Loop =====
  function loop(ts) {
    if (!running) return;
    const dtMs = Math.max(0, Math.min(34, ts - lastTs));
    const dt = dtMs / 1000;
    lastTs = ts;

    update(dt, dtMs);
    render(dt);
    requestAnimationFrame(loop);
  }

  function update(dt, dtMs) {
    elapsed += dt;
    remaining = Math.max(0, DIFF[difficulty].time - elapsed);

    if (remaining <= 0) {
      if (score > best) {
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
      }
      updateHud();
      gameOver("TIME");
      return;
    }

    // weather
    updateWeather(dt);

    aim.smooth = lerp(aim.smooth, aim.angle, 1 - Math.pow(0.001, dt*60));
    aim.smooth = clamp(aim.smooth, -Math.PI + 0.26, -0.23);

    arrowCooldown = Math.max(0, arrowCooldown - dtMs);

    const left = keys.has("ArrowLeft") || keys.has("a") || keys.has("A");
    const right = keys.has("ArrowRight") || keys.has("d") || keys.has("D");
    if (left) aim.angle -= dt * 1.9;
    if (right) aim.angle += dt * 1.9;
    aim.angle = clamp(aim.angle, -Math.PI + 0.26, -0.23);

    const cfg = DIFF[difficulty];
    const wind = cfg.wind;

    for (const c of coins) {
      c.spin = (c.spin + dt * 0.9) % 1;
      c.bob += dt * 2.4;
      c.x += c.vx * dt;
      c.y += c.vy * dt;
      if (c.x < LEFT + c.r) { c.x = LEFT + c.r; c.vx *= -1; }
      if (c.x > RIGHT - c.r) { c.x = RIGHT - c.r; c.vx *= -1; }
      if (c.y < TOP + c.r) { c.y = TOP + c.r; c.vy *= -1; }
      if (c.y > BOTTOM - c.r) { c.y = BOTTOM - c.r; c.vy *= -1; }
    }

    for (const h of hazards) {
      h.blink = (h.blink + dt * 1.5) % 1;
      h.x += h.vx * dt;
      h.y += h.vy * dt;
      if (h.x < LEFT + h.r) { h.x = LEFT + h.r; h.vx *= -1; }
      if (h.x > RIGHT - h.r) { h.x = RIGHT - h.r; h.vx *= -1; }
      if (h.y < TOP + h.r) { h.y = TOP + h.r; h.vy *= -1; }
      if (h.y > BOTTOM - h.r) { h.y = BOTTOM - h.r; h.vy *= -1; }
    }

    if (shakeT > 0) {
      shakeT = Math.max(0, shakeT - dt);
      shakePow = lerp(shakePow, 0, 1 - Math.pow(0.001, dt*60));
      shakePhase += dt * 22;
    }

    const g = 820;
    for (const ar of arrows) {
      ar.vy += g * dt;
      ar.vx += wind * dt * 38;

      ar.x += ar.vx * dt;
      ar.y += ar.vy * dt;

      ar.rot = Math.atan2(ar.vy, ar.vx);

      ar.trail.push([ar.x, ar.y]);
      if (ar.trail.length > 10) ar.trail.shift();

      if (ar.y > H + 90 || ar.x < -90 || ar.x > W + 90) ar.alive = false;
      if (!ar.alive) continue;

      for (const h of hazards) {
        if (hitCircle(ar.x, ar.y, h.x, h.y, h.r * 0.92)) {
          ar.alive = false;
          burst(h.x, h.y, 42, "red");
          ring(h.x,h.y,h.r*1.6,"red");
          addPopup(h.x, h.y - 6, "BOOM", true, "red");
          addShake(10, 0.20);

          if (score > best) {
            best = score;
            localStorage.setItem(BEST_KEY, String(best));
          }
          updateHud();
          gameOver("HAZARD");
          return;
        }
      }

      for (const c of coins) {
        const cy = c.y + Math.sin(c.bob) * 2.5;
        if (hitCircle(ar.x, ar.y, c.x, cy, c.r * 0.94)) {
          ar.alive = false;

          const crit = hitCircle(ar.x, ar.y, c.x, cy, c.core);
          let add = c.points;
          if (crit) add = Math.round(add * 2);
          add = Math.round(add * cfg.bonus);

          score += add;
          if (score > best) {
            best = score;
            localStorage.setItem(BEST_KEY, String(best));
          }

          burst(c.x, cy, crit ? 34 : 20, crit ? "gold" : "mint");
          ring(c.x,cy,c.r*(crit?1.9:1.5), crit ? "gold" : "mint");
          addPopup(c.x, cy - 6, `+${add}`, crit, "gold");
          addShake(crit ? 6 : 3, 0.12);

          if (crit) sfx.crit(); else sfx.hit();

          // respawn + random skin
          c.x = rnd(LEFT + c.r, RIGHT - c.r);
          c.y = rnd(TOP + c.r, BOTTOM - 170);
          c.vx = (Math.random()*300-150) * cfg.move;
          c.vy = (Math.random()*240-120) * cfg.move;
          c.spin = Math.random();
          c.bob = Math.random()*10;
          c.skin = (Math.random()*starSkins.length) | 0;

          break;
        }
      }
    }
    arrows = arrows.filter(a => a.alive);

    for (const p of particles) {
      p.t += dt;
      if (p.kind.endsWith("_ring")) continue;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt * 2.0);
      p.vy *= (1 - dt * 2.0);
      p.rot += (p.spin || 0) * dt;
    }
    particles = particles.filter(p => p.t < p.life);

    for (const s of popups) {
      s.t += dt;
      s.y += s.vy * dt;
      s.vy *= (1 - dt * 2.1);
      s.x += Math.sin((s.t*6)+s.wob) * 0.35;
    }
    popups = popups.filter(s => s.t < s.life);

    updateHud();
  }

  function render(dt) {
    ctx.save();

    // ✅ 연속 shake (랜덤 jitter 제거)
    if (shakeT > 0 && shakePow > 0.1) {
      const k = (shakeT / 0.20);
      const s = shakePow * k;
      const ox = Math.sin(shakePhase) * s;
      const oy = Math.cos(shakePhase*1.3) * s;
      ctx.translate(ox, oy);
    }

    // background (cached)
    if (!bgBuilt) buildBackground();
    ctx.drawImage(bgCanvas, 0, 0);

    // fog/rain (animated)
    renderWeather();

    // border
    ctx.save();
    ctx.strokeStyle = "rgba(255,210,120,0.14)";
    ctx.lineWidth = Math.max(2, Math.min(W,H) * 0.004);
    drawRoundedRect(LEFT, TOP, RIGHT - LEFT, BOTTOM - TOP, Math.max(14, Math.min(W,H)*0.03));
    ctx.stroke();
    ctx.restore();

    // hazards
    for (const h of hazards) drawHazard(h.x, h.y, h.r, h.blink);

    // stars
    for (const c of coins) drawStarCoin(c);

    // popups
    for (const s of popups) {
      const a = 1 - (s.t / s.life);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.font = `${Math.max(13, Math.round(Math.min(W,H)*0.028))}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillText(s.text, s.x + 1, s.y + 2);

      ctx.fillStyle = (s.colorKind === "red")
        ? "rgba(255,59,92,0.98)"
        : (s.isCrit ? "rgba(255,213,74,0.98)" : "rgba(255,248,225,0.95)");
      ctx.fillText(s.text, s.x, s.y);

      if (s.isCrit) {
        const sz = Math.max(18, Math.round(Math.min(W,H)*0.05));
        const img = starSkins[0]?.canvas;
        if (img) {
          ctx.globalAlpha = a * 0.85;
          ctx.drawImage(img, s.x - sz/2, s.y - sz*1.35, sz, sz);
        }
      }
      ctx.restore();
    }

    // arrows + trail
    for (const ar of arrows) {
      ctx.save();
      for (let i=0;i<ar.trail.length;i++){
        const p = ar.trail[i];
        const alpha = (i / ar.trail.length) * 0.28;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "rgba(255,243,215,0.90)";
        ctx.fillRect(p[0], p[1], 3, 3);
      }
      ctx.restore();

      ctx.save();
      ctx.translate(ar.x, ar.y);
      ctx.rotate(ar.rot);

      ctx.fillStyle = "rgba(255,243,215,0.95)";
      ctx.fillRect(-18, -2, 28, 4);

      ctx.fillStyle = "rgba(255,213,74,0.98)";
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(23, -7);
      ctx.lineTo(23, 7);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(46,242,194,0.98)";
      ctx.fillRect(-25, -6, 4, 12);

      ctx.restore();
    }

    // particles
    for (const p of particles) {
      const a = 1 - (p.t / p.life);
      ctx.save();
      ctx.globalAlpha = a;

      if (p.kind.endsWith("_ring")) {
        const k = p.t / p.life;
        const rr = p.r0 * (0.7 + k*1.1);
        ctx.lineWidth = 3;
        ctx.strokeStyle =
          p.kind.startsWith("gold") ? `rgba(255,213,74,${0.8*a})` :
          p.kind.startsWith("red")  ? `rgba(255,59,92,${0.7*a})` :
                                      `rgba(46,242,194,${0.7*a})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, rr, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
        continue;
      }

      ctx.fillStyle =
        p.kind === "gold" ? "rgba(255,213,74,0.95)" :
        p.kind === "red"  ? "rgba(255,59,92,0.90)" :
        p.kind === "mint" ? "rgba(46,242,194,0.90)" :
                            "rgba(255,255,255,0.75)";

      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot || 0);
      const s = p.size || 3;
      ctx.fillRect(-s/2, -s/2, s, s);
      ctx.restore();
    }

    // player + crossbow
    drawPlayerAndCrossbow();

    drawVignette(ctx);
    ctx.restore();
  }

  function drawPlayerAndCrossbow(){
    // player base
    ctx.save();
    ctx.fillStyle = "rgba(46,242,194,0.16)";
    ctx.strokeStyle = "rgba(46,242,194,0.52)";
    ctx.lineWidth = Math.max(2, Math.min(W,H)*0.005);
    ctx.beginPath();
    ctx.arc(player.x, player.y, Math.max(14, Math.min(W,H)*0.03), 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // aim guide
    const ax = Math.cos(aim.smooth), ay = Math.sin(aim.smooth);
    const bx = player.x + ax * (Math.min(W,H)*0.12);
    const by = player.y + ay * (Math.min(W,H)*0.12);

    ctx.save();
    ctx.strokeStyle = "rgba(255,213,74,0.88)";
    ctx.lineWidth = Math.max(2, Math.min(W,H)*0.0045);
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(bx, by);
    ctx.stroke();

    ctx.globalAlpha = 0.48;
    ctx.strokeStyle = "rgba(255,243,215,0.34)";
    ctx.setLineDash([7, 7]);
    ctx.beginPath();
    ctx.moveTo(bx, by);
    ctx.lineTo(bx + ax * (Math.min(W,H)*0.46), by + ay * (Math.min(W,H)*0.46));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    // crossbow
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(aim.smooth);

    // mild shadow (no blur)
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.beginPath();
    ctx.ellipse(Math.min(W,H)*0.05, Math.min(W,H)*0.04, Math.min(W,H)*0.12, Math.min(W,H)*0.045, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const scale = Math.min(W,H) / 1700;
    const iw = 720 * scale, ih = 420 * scale;

    if (crossbowImg.complete && crossbowImg.naturalWidth) {
      ctx.drawImage(crossbowImg, -iw*0.08, -ih*0.52, iw, ih);
    } else {
      ctx.strokeStyle = "rgba(255,213,74,0.92)";
      ctx.lineWidth = 10;
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(70, 0);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ===== Init =====
  resizeCanvasToStage();
  buildBackground();
  buildStarSkins();
  initWeather();
  bgBuilt = true;

  bestText.textContent = String(best);
  scoreText.textContent = "0";
  timeText.textContent = String(DIFF[difficulty].time.toFixed(1));
  showStartOverlay();

  diffButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      if (!running) timeText.textContent = String(DIFF[difficulty].time.toFixed(1));
    });
  });
})();
</script>
</body>
</html>
